【数据结构泛刷】



【1】



1.http://codeforces.com/problemset/problem/1140/F

注：线段树维护一组set中最大值的变化，查询>=pos下标中值>=x的最小下标，在指定set中进一步维护或者查询




2.http://codeforces.com/problemset/problem/1140/F

注：经典的线段树分治，提取每个插入操作的存活周期，抹除删除操作

线段树标记永久化思想(一个周期分成log段)，在线段树上dfs，递归时执行插入操作，回溯时撤销

使用可撤销并查集(按秩启发式合并)，在叶节点状态回答询问

维护答案：刚开始每个横坐标和纵坐标单独一个集合，每个集合维护其中横纵坐标个数；

插入一条边，即可能合并两个集合，对答案贡献为numx[p]*numy[q] + numy[p]*numx[p]

注意撤销时的操作顺序，不要忘了维护并查集结构



3.http://codeforces.com/problemset/problem/13/E

注：简单分块+并查集，也可以用lct(注意模板中rev标记不能删除)


4.http://codeforces.com/problemset/problem/580/E

注：线段树区间替换，区间查询hash值



5.http://codeforces.com/problemset/problem/484/E

注：二分+可持久化线段树，离线从大到小插入权值，维护01串，查询区间最长"1"段的长度，典型的三段论线段树

特别注意：merge函数，不要把参数设置成const node &p形式，让其自然的拷贝，

避免x=merge(x,y)中x自更新不完全导致的错误



6.http://codeforces.com/problemset/problem/557/E

注：经典的01字典树上求k大值问题，形式类似于：问给定01串中所有子串字典序k大的子串，O(n^2)



7.http://codeforces.com/problemset/problem/710/F

**注**：经典的强制在线ac自动机，维护一个字符串集合，支持动态插入串，动态删除串，在线查询给定串在集合中子串数目

**消除动态删除**：维护两个ac自动机森林in和out，插入串插入到in，删除串插入到out，因为此种数目满足减法性质，分别查询相减即可(代价为一个2)

**消除在线插入**：ac自动机不可在线插入串，采用二进制分组算法，在线转离线，每次插入一个串，新建一个ac自动机，阶为1，如果与上一个ac自动机阶相同，就合并到上一个，暴力重构合并之后的自动机fail树和维护的相关信息(每个串最多合并log次)，此步本质上是一种离线做法(代价为一个log)

**在线查询**：在森林中每个自动机上分别查询，叠加即可；ac自动机查询是在线的

**技巧与注意点**：

1)0号点设立为森林中所有点共用的超级虚拟节点，每个自动机空串节点插入时再自己维护

2)设S=rt[k]为第k个自动机的根，也是当前要操作的根节点，千万注意在插入完之后的构建build过程和对每个自动机的查询过程中，都要初始化一下此自动机：将0号点的每一个转移都设为S，即：go[0][c]=S

3)特别注意不要构造trie图，保留节点的每个空转移

**关于ac自动机的合并**

1)本质是DAG的合并

2)注意合并的时候，不要忘记合并节点的标记，考虑标记合并时到底是或还是加的关系，也有可能是多规则合并

**本题其他参考做法**：

1)二进制分组+后缀自动机，思路类似

2)采用分类算法，对串长设立阈值，长一点的暴力插入ac自动机中并维护，短一点的存起来暴力kmp匹配，速度较快

3)字符串hash：用到基本思想，总串长为一定规模的若干字符串，其长度种类不超过根号种

对每种长度利用一个set维护插入串的hash值，查询时扫描所有不同长度种类，再扫描此种长度的所有子串，去指定set中查询此子串hash值是否存在，其总复杂度暂不明晰





8.http://codeforces.com/problemset/problem/1083/C

注：线段树合并式dp，一个节点[l,r]存储树上包含此闭区间数值的最小链端点对，此信息可单点修改，合并维护

查询最小非法前缀，查询时，带一个动态修改的查询参数，表示当前区间[l,r]严格前面的区间[0,l-1]的信息并

查询时，左子树不可并，递归去左子树，否则右子树；叶节点特判是否符合












