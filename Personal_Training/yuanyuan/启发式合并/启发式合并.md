# 启发式合并

start time: 2019/3/31 15:06

end time:

## 学习资料

[CF blog: dsu on tree](https://codeforces.com/blog/entry/44351)

[上面那篇的翻译](https://blog.csdn.net/QAQ__QAQ/article/details/53455462)

[zzq blog: dsu on tree](https://www.cnblogs.com/zzqsblog/p/6146916.html)

并查集
1.http://codeforces.com/contest/778/problem/C

伸展树
2.http://www.lydsy.com/JudgeOnline/problem.php?id=2809

链表
3.http://www.lydsy.com/JudgeOnline/problem.php?id=1483

treap
4.http://www.lydsy.com/JudgeOnline/problem.php?id=2733

treap
5.http://poj.org/problem?id=1471

map
6.http://acm.uestc.edu.cn/#/problem/show/1284

LCT
7.http://www.cnblogs.com/geng4512/p/5296855.html

主席树
8.http://www.lydsy.com/JudgeOnline/problem.php?id=3123

set
9.http://bestcoder.hdu.edu.cn/contests/contest_showproblem.php?cid=775&pid=1002

10.http://codeforces.com/contest/375/problem/D

线段树

https://wenku.baidu.com/view/88f4e134e518964bcf847c95.html

11.http://codeforces.com/contest/893/problem/F

12.http://www.lydsy.com/JudgeOnline/problem.php?id=4552

13.https://nanti.jisuanke.com/t/30997

## dsu on tree

### 模板

```c++
// id starts with 1
namespace QuerySubtree{
    static const int N = ::N;
    int sz[N] , wson[N] , par[N];
    void dfs(int c,int fa,vi g[]){
        sz[c]=1;par[c]=fa;int &s=wson[c]=0;
        for(auto t:g[c]) if(t!=fa)
            dfs(t,c,g),sz[c]+=sz[t],(sz[t]>=sz[s])&&(s=t);
    }
  	vi nd;
    void solve(int c,int fa,bool iswson,vi g[]){
        for(auto t : g[c]) if(t != wson[c] && t != fa) solve(t , c , false , g);
        if(wson[c]) solve(wson[c] , c , true , g);
        for(auto t : g[c]) if(t != wson[c] && t != fa) {
            // 将该子树的信息加入
        }
      	// 将当前节点的信息加入
      	// 查询
        if(!iswson) {
        	// 删除整棵子树的信息 nd.clear()
        }
    }
    void solve(vi g[]){
        dfs(1,0,g);
        solve(1,0,false,g); // 如果输入是单组数据，改成 true 可以优化
    }
}
```

### 复杂度

对于一个子树，我们已经有了重儿子子树的信息了，只要把轻儿子信息更新上来就行了。一个点到根有 log 条轻边，因此一个点只会被加 log 次。总的复杂度 $O(nlog_2n)$

### 做题

#### CF600E

模板题